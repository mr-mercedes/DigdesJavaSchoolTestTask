¬ступительное задание

–еализаци€ некоторого подоби€ €зыка управлени€ данными в коллекции. ќсновные команды, которые должны поддерживатьс€ это вставка элементов в коллекцию, удаление элемента из коллекции, поиск элементов в коллекции, изменение элементов в коллекции. 
—труктура коллекции заранее определена.

ќписание задачи: 
 оллекци€ данных в данной задаче это структура представл€юща€ собой некоторую таблицу данных, в которой есть наименовани€ колонок и кажда€ строчка в таблице это элемент коллекции.
Ќеобходимо реализовать метод, который на вход получает команду в виде строки (требовани€ к формату будет ниже).  оманда должна выполн€ть четыре основные операции  вставка, изменение, поиск и удаление элементов из коллекции данных.
“акже при изменении, удалении и поиске должны поддерживатьс€ услови€ выборки из коллекции (ниже они будут представлены). 

Ќа выход список элементов в коллекции, которые были найдены, либо которые были изменены, либо которые были добавлены, либо которые были удалены.


“ребовани€ к задаче:

“ребовани€ к коллекции:

 оллекци€ представл€ет из себ€ таблицу в виде List<Map<String,Object>> . √де List это список строк в таблице. Map это значени€ в колонках, где ключом Map €вл€етс€ наименование колонки в виде строки, а значением Map €вл€етс€ значение в €чейке таблицы (допустимые типы значений в €чейках: Long, Double, Boolean, String).
 





Ќапример таблица с пользовател€ми вида:

“аблица 1: —писок пользователей.
id	lastName	age	cost	active
1	ѕетров	30	5.4	true
2	»ванов	25	4.3	false


ћожет быть представлена в виде:
Map<String,Object> row1 = new HashMap<>();
row1.put("id",1);
row1.put("lastName","ѕетров");
row1.put("age",30);
row1.put("cost",5.4);
row1.put("active", true);

Map<String,Object> row2 = new HashMap<>();
row2.put("id",2);
row2.put("lastName","»ванов");
row2.put("age",25);
row2.put("cost",4.3);
row2.put("active", false);

List<Map<String,Object>> data = new ArrayList<>();
data.add(row1);
data.add(row2);

”никальность значений в €чейках не провер€етс€, т.е. может быть две записи с id=1 или две записи с lastName=Ф»вановФ. “акже некоторые значени€ могут быть пустыми, но все значени€ в €чейках в одной строчке пустыми быть не могут.




“ребовани€ к формату запроса с командой, поступающей на вход:
¬озможные команды: 
INSERT - вставка элемента в коллекцию,
UPDATE  изменение элемента в коллекции,
DELETE - удаление элемента из коллекции,
SELECT - поиск элементов в коллекции.

¬озможные операторы сравнени€:
ѕеред началом оператора сравнени€ должен сто€ть оператор WHERE - оператор, который говорит, что команда должна выполн€тьс€ с условием выборки.

“аблица 2: —писок операторов сравнени€.
є	ќператор	Ќазначение	ѕримеры
1	=	ќператор равно. ¬озвращает true если два значени€ и их типы равны между собой, иначе false. ѕримен€етс€ на типы данных: 
Boolean, String, Long, Double	5=5 вернет true,
СtestТ=ТtestТ вернет true
5=ТtestТ вернет false
С5Т=5 вернет false
true=true вернет true
false=false вернет true
5=false вернет false
5=5.0 вернет false

2	!=	ќператор не равно. ¬озвращает true если два значени€ или их типы не равны между собой, иначе false. ѕримен€етс€ на типы данных: 
Boolean, String, Long, Double
	5!=5 вернет false,
СtestТ!=ТtestТ вернет false
5!=ТtestТ вернет true
С5Т!=5 вернет true
true!=true вернет false
false!=false вернет false
5!=false вернет true
5!=5.0 вернет true
3	like	ќператор поиска удовлетвор€ющих шаблону. Ўаблон может быть следующих видов: СстрокаТ, Сстрока%Т, С%строка%Т, С%строкаТ. ѕримен€етс€ на типы данных: String	СtestТ like СtestТ вернет true
СtestТ like СtEstТ вернет false
СtestТ like Сtest%Т вернет true
СtestADТ like Сtest%Т вернет true
СADtestADТ like Сtest%Т вернет false
СtestТ like С%testТ вернет true
СADtestТ like С%testТ вернет true
СADtestADТ like С%testТ вернет false
СADtestAТ like С%test%Т вернет true
СtestТ like С%test%Т вернет true
СADteAstТ like С%test%Т вернет false
4	ilike	ќператор поиска удовлетвор€ющих шаблону. ¬ыполн€етс€ аналогично оператору like, но без учета регистра. Ўаблон может быть следующих видов: СстрокаТ, Сстрока%Т, С%строка%Т, С%строкаТ. ѕримен€етс€ на типы данных: String	СtestТ like СtestТ вернет true
СtestТ like СtEstТ вернет true
СtestТ like СtEst%Т вернет true
СtestADТ like Сtest%Т вернет true
СADtestADТ like Сtest%Т вернет false
СtestТ like С%testТ вернет true
СADtestТ like С%testТ вернет true
СADtestADТ like С%testТ вернет false
СADtestAТ like С%test%Т вернет true
СtestТ like С%test%Т вернет true
СADteAstТ like С%test%Т вернет false
5	>=
	ќператор больше равно. ѕримен€етс€ дл€ типов: Long, Double	0>=0.1 вернет false
0>=0 вернет true
0>=-1 вернет true
0>=Т0Т вернет ошибку
1>=true вернет ошибку
0.1>=1 вернет false

6	<=	ќператор меньше равно. ѕримен€етс€ дл€ типов: Long, Double	0<=0.1 вернет true
0<=0 вернет true
0<=-1 вернет false
0<=Т0Т вернет ошибку
1<=true вернет ошибку
0.1<=1 вернет true
7	<	ќператор меньше. ѕримен€етс€ дл€ типов: Long, Double	0<0.1 вернет true
0<0 вернет false
0<-1 вернет false
0<Т0Т вернет ошибку
1<true вернет ошибку
0.1<1 вернет true
8	>	ќператор больше. ѕримен€етс€ дл€ типов: Long, Double	0>0.1 вернет false
0>0 вернет false
0>-1 вернет true
0>Т0Т вернет ошибку
1>true вернет ошибку
0.1>1 вернет false










Ћогические операторы: 
“аблица 3: —писок логических операторов.
є	ќператор	Ќазначение	ѕримеры
1	AND	Ћогический оператор У»Ф.	0>=0 AND СtestТ like СtestТ вернет true

0>0 AND СtestТ like СtestТ вернет false
2	OR	Ћогический оператор У»Ћ»Ф.	0>0 OR СtestТ like СtestТ вернет true

0>0 OR СtEstТ like СtestТ вернет false

0>=0 OR СtestТ like СtestТ вернет true
  
* ѕоддержку скобок реализовывать не нужно.          


¬ставка и изменение €чеек:
ƒл€ вставки новых значений или изменение существующих необходимо передавать в строку запроса оператор VALUES и далее им€ колонки = значение (через зап€тую). 














ѕримеры запросов:
ѕример 1: ѕример добавлени€ строки в коллекцию:
Ќа вход подаетс€ запрос:
INSERT VALUES СlastNameТ = С‘едоровТ , СidТ=3, СageТ=40, СactiveТ=true

„то означает, что должна быть добавлена запись в коллекцию вида (на примере “аблица 1): 

“аблица 1.1: –езультат добавлени€
id	lastName	age	cost	active
1	ѕетров	30	5.4	true
2	»ванов	25	4.3	false
3	‘едоров	40		true

Map<String,Object> row3 = new HashMap<>();
row3.put("id",3);
row3.put("lastName","‘едоров");
row3.put("age",40);
row3.put("active", true);

data.add(row3);

Ќа выход из метода: List<Map<String,Object>> в которой содержитс€ row3 (со всеми колонками, в которых есть значение).


ѕример 2: ѕример изменени€ строки в коллекции:
Ќа вход подаетс€ запрос:
UPDATE VALUES СactiveТ=false, СcostТ=10.1 where СidТ=3

„то означает, что должны быть изменены строки, у которых колонка id равна 3 (на примере “аблица 1.1): 

“аблица 1.2: –езультат изменени€
id	lastName	age	cost	active
1	ѕетров	30	5.4	true
2	»ванов	25	4.3	false
3	‘едоров	40	10.1	false

row3.put("cost",10.1);
row3.put("active", false);

Ќа выход из метода: List<Map<String,Object>> в которой содержитс€ row3 с измененными данными (со всеми колонками, в которых есть значение).

ѕример 3: ѕример изменени€ строк в коллекции:
Ќа вход подаетс€ запрос:
UPDATE VALUES СactiveТ=true  where СactiveТ=false

„то означает, что должны быть изменены все строки, у которых колонка active равна false (на примере “аблица 1.2): 

“аблица 1.3: –езультат изменени€
id	lastName	age	cost	active
1	ѕетров	30	5.4	true
2	»ванов	25	4.3	true
3	‘едоров	40	10.1	true


row3.put("active", true);
row2.put("active", true);

Ќа выход из метода: List<Map<String,Object>> в которой содержитс€ row3 с измененными данными (со всеми колонками, в которых есть значение).

ѕример 4: ѕример поиска строк в коллекции:
Ќа вход подаетс€ запрос:
SELECT WHERE СageТ>=30 and СlastNameТ ilike С%п%Т

„то означает, что необходимо найти все строки, у которых значение в колонке age больше или равно 30 и значение в колонке lastName содержит букву СпТ без учета регистра (на примере “аблица 1.3): 


Ќа выход из метода: List<Map<String,Object>> в которой содержитс€ row1, поскольку только перва€ строчка попадает под услови€ выборки.


ѕример 5: ѕример удалени€ строк в коллекции:
Ќа вход подаетс€ запрос:
DELETE WHERE СidТ=3

„то означает, что необходимо удалить все строчки, в которых в колонке id значение равно 3. (на примере “аблица 1.3): 

“аблица 1.4: –езультат удалени€
id	lastName	age	cost	active
1	ѕетров	30	5.4	true
2	»ванов	25	4.3	true


Ќа выход из метода: List<Map<String,Object>> в которой содержитс€ row3, поскольку только треть€ строчка попадает под услови€ выборки.



 оманды DELETE, SELECT, UPDATE могут выполн€тьс€ без услови€ WHERE. ¬ этом случае все записи должны быть получены, изменены или удалены.
 оманда INSERT всегда выполн€етс€ без оператора WHERE.
“ребовани€ к реализации:

»сходники необходимо выложить под своей учетной записью  на  GitHub и выдать права на чтение дл€ digdesjavaschool@gmail.com. 
¬се ¬аши классы должны лежать в java пакете: com.digdes.school
¬ этом пакете должен лежать класс JavaSchoolStarter, в котором есть метод execute на вход передаетс€ строка, а на выход List<Map<String,Object>>. ƒефолтный конструктор без аргументов об€зательно должен быть (он указан в примере).
ѕример:
package com.digdes.school;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class JavaSchoolStarter {
  //ƒефолтный конструктор
public JavaSchoolStarter(){
  
}

  //Ќа вход запрос, на выход результат выполнени€ запроса
   
}
—кобки в услови€х реализовывать не нужно, но если сделаете - будет плюсом.
ѕровер€тьс€ будет в первую очередь корректность исполнени€ запроса, потом уже только сама реализаци€ и код.
≈сли не все реализовано - сообщить об этом.
¬алидацию запроса провер€ть не нужно, но если сделаете - будет плюсом 
≈сли в запросе есть наименование колонки, которой нет в таблице - выдать Exception. “акже если в сравнении участвует тип, который не поддерживаетс€ данным оператором выкинуть также Exception ( например СlastNameТ>10 
Ќаименование колонок и структуру данных берем из примера (см. “аблица 1).  олонка id имеет тип Long, колонка lastName имеет тип String, колонка cost имеет тип Double, колонка age имеет тип Long, колонка active имеет тип Boolean.
 оллекци€ на старте должна быть пустой (изначально не заполн€ть).
Ћишние пробелы игнорируютс€, но в значении €чейки учитываютс€. Ќапример СageТ>4  равносильно СageТ > 4.
 Ќаименование колонок и строковые значени€ оборачиваютс€ в одинарные кавычки. Ќапример наименование колонки age в запросе должна быть в одинарных кавычках (как в примерах запроса). ј числа и булевые значени€ без кавычек (как в примерах запроса).
«начени€ которые передаютс€ на сравнение не могут быть null. ј при записи значение колонки может быть null. “.е. СageТ>=null считаем, что такого не может быть. ј UPDATE VALUES СageТ=null - может быть, в этом  случае значение из €чейки удал€етс€.
≈сли значение в €чейке например age пусто (null), а на вход передаетс€ условие типа СageТ!=0 , а существующее значение age=null. “о запрос считаетс€ корректным, 0!=null. 
  олонки и команды должны быть регистро независимыми. “.е. INSERT тоже самое, что insert. lastName тоже самое, что и lastname и LASTNAME. WHERE тоже самое, что и where.
  од должен быть компилируемым и исполн€ем под OpenJDK 18.
 —торонние библиотеки использовать нельз€. –еализаци€ на чистом OpenJDK 18.
ƒанные в коллекции должны сохран€тьс€ на врем€ исполнени€ программы. “.е. последовательно можно вызвать несколько команд.  ак в примере ниже.
ѕример вызова:

package com.digdes.school;


import java.util.List;
import java.util.Map;

public class Main {

   public static void main(String... args){
       JavaSchoolStarter starter = new JavaSchoolStarter();
       try {
           //¬ставка строки в коллекцию
           List<Map<String,Object>> result1 = starter.execute("INSERT VALUES 'lastName' = '‘едоров' , 'id'=3, 'age'=40, 'active'=true");
           //»зменение значени€ которое выше записывали
           List<Map<String,Object>> result2 = starter.execute("UPDATE VALUES 'active'=false, 'cost'=10.1 where 'id'=3");
           //ѕолучение всех данных из коллекции (т.е. в данном примере вернетс€ 1 запись)
           List<Map<String,Object>> result3 = starter.execute("SELECT");
          
       }catch (Exception ex){
           ex.printStackTrace();
       }
   }
}















